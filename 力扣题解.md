# 力扣题解

1. 两数之和

   ```c++
   // 暴力解法
   // sizeof会造成溢出访问数组的问题，size则没有问题
   class Solution {
    public:
        vector<int> twoSum(vector<int>& nums, int target) {
            int l = nums.size();
            int o1,o2;
            int flag=0;
            for(int i=0; i<l; i++){
                for(int j=i+1; j<l; j++){
                    if(nums[i]+nums[j]==target){
                        o1=i;
                        o2=j;
                        flag = 1;
                        break;
                    }
                }
                if(flag==1){
                    break;
                }
            }
            return {o1,o2};
        }
    };
   ```

2. 整数反转

    ```c++
    // 溢出检测问题比较多，看有没有可以精简的地方
    double o = 0;
    int m, flag=0;

    if (x < 0) {
        if(x<=-pow(2,31)){
            return 0;
        }
        x = -x;
        flag = 1;
    }
    while (1) {
        m = x % 10;
        o = o * 10 + m;
        x /= 10;
        if (x==0)
        {
            break;
        }
    }
    if (o>=pow(2,31)){
        return 0;
    }
    if (flag == 1) {
        return -o;
    }
    else {
        return o;
    }
    ```

3. 回文数

   ```c++
   // 采用生成反转数的方法进行判断
    while (x>=0)
    {
        double r = 0;
        int y = x, yy;
        while (y > 0) {
            yy = y % 10;
            r = r * 10 + yy;
            y /= 10;
        }
        if (x == r) {
            return true;
        }
        else
        {
            return false;
        }
    }
    return false;
   ```

4. 罗马数字转整数

   ```c++
   // 程序没啥问题，就是执行太慢
   map<string, int> Roma = {
       {"I",1},{"IV",4},{"V",5},{"IX",9},{"X",10},{"XL",40},{"L",50},
       {"XC",90},{"C",100},{"CD",400},{"D",500},{"CM",900},{"M",1000}
       };
    int o = 0;
    for (int i = 0; i < s.length(); i++) {
        string s1 = s.substr(i, 2);
        if (Roma.find(s1) != Roma.end()) {
            // 找到双字符
            i += 1;
        }
        else{
            // 单字符
            s1 = s.substr(i, 1);
        }
        o += Roma.at(s1);
    }
    return o;
   ```

5. 最长公共前缀

   ```c++
   class Solution {
       public:
       string longestCommonPrefix(vector<string>& strs) {
           int num=0,flag=0;
           if(strs.size()>=1){
               for(int i=0;i<strs[0].size();i++){
                   string cp = strs[0].substr(0,i+1);
                   for(int j=1;j<strs.size();j++){
                       if (strs[j].substr(0, i + 1) != cp){
                           num = i;
                           flag=1;
                           break;
                        }
                    }
                    if(flag==1){
                        break;
                    }
                }
                if(flag==1){
                    return strs[0].substr(0,num);
                }else{
                    return strs[0];  // 两个字符串完全按相同或只有一个字符串时
                }
            }
            else{
                return "";   // 传入字符串为空时
            }
        }
    };
   ```

6. 有效的括号

    ```c++
    class Solution {
    public:
        bool isValid(string s) {
            string ss;
            map<string, string> mk = {
                {"{", "}"}, {"[", "]"}, {"(", ")"}
            };
            for (int i = 0; i < s.size(); i++) {
                if (s.substr(i, 1) == "{" || s.substr(i, 1) == "(" || s.substr(i, 1) == "[") {
                    ss.append(s.substr(i, 1));
                }
                else if (ss.size() != 0 && s.substr(i, 1) == mk.at(ss.substr(ss.size() - 1, 1))) {
                    ss.erase(ss.size() - 1, 1);
                }
                else {
                    return false;
                }
            }
            if (ss.size() == 0) {
                return true;
            }
            else {
                return false;
            }
        }
    };
    ```

7. 合并两个有序链表

    ```c++
    // 官方解法，不开心
    class Solution {
    public:
        ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
            ListNode* ll = new ListNode(0);
            ListNode* l3 = ll;
            while(l1 != NULL && l2 != NULL){
                if(l1->val < l2->val){
                    l3->next = l1;
                    l1 = l1->next;
                }else{
                    l3->next = l2;
                    l2 = l2->next;
                }
                l3 = l3->next;
            }
            l3->next = l1!=NULL ? l1:l2;
            return ll->next;
        }
    };
    ```

8. 删除排序数组中的重复项

    ```c++
    // 还是官方的解法，跟vector没半毛钱关系，我佛了
    class Solution {
    public:
        int removeDuplicates(vector<int>& nums) {
            if(nums.size()==0){return 0;}
            int n = 0;
            for(int i=0;i<nums.size();i++){
                if(nums[i]!=nums[n]){
                    n++;
                    nums[n] = nums[i];
                }
            }
            return n+1;
        }
    };
    ```

9. 移除元素

    ```c++
    // 跟上一题一样的思路，两个游标
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int n = 0;
            for(int i=0;i<nums.size();i++){
                if(nums[i]!=val){
                    nums[n] = nums[i];
                    n++;
                }
            }
            return n;
        }
    };
    ```

10. 实现strStr()

    ```c++
    // 调用函数
    class Solution {
    public:
        int strStr(string haystack, string needle) {
            int x = haystack.find(needle);
            return x;
        }
    };
    ```

    ```c++
    // 一般的解法
    class Solution {
    public:
        int strStr(string haystack, string needle) {
            if (needle.size() == 0) { return 0; }
            int i = 0;
            while (haystack[i] != '\0') {
                if (haystack[i] == needle[0]) {
                    int j = 0;
                    while (needle[j] != '\0') {
                        char ss1 = haystack[i + j];
                        char ss2 = needle[j];
                        if (haystack[i + j] == needle[j]) { j++; }
                        else { break; }
                    }
                    if(j==needle.size()){return i;}
                }
                if (haystack.size() - i < needle.size()) { return -1; }
                i++;
            }
            return -1;
        }
    };
    ```

11. 搜索插入位置

    ```c++
    // 毫无技术含量的最简单解法
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) {
            int n = nums.size();
            if(target>nums[n-1])return n;
            for(int i=0;i<n;i++){
                if(nums[i]>=target){
                    return i;
                }
            }
            return 0;
        }
    };

    ```

12. 报数

    ```c++
    // 题目不太好理解
    // 用递归或许会简单一些
    // 这道题主要还是题目不好理解

    #include <stdio.h>
    #include <string>
    #include <iostream>

    using namespace std;

    string solution(int n) {
        string s = "1";
        string s1 = "";
        if (n == 1)return s;
        for (int i = 1; i < n; i++) {
            int count = 1;
            for (int j = 0; j < s.size(); j++) {
                if (s[j + 1] == '\0') {
                    s1.append(to_string(count));
                    s1.append(s.substr(j, 1));
                    break;
                } else if (s[j + 1] == s[j]) {
                    count++;
                } else {
                    s1.append(to_string(count));
                    s1.append(s.substr(j, 1));
                    count = 1;
                }
            }
            s = s1;
            s1.clear();
        }
        return s;
    }


    int main() {
        int n = 0;
        printf("Input a number:");
        scanf("%d", &n);
        cout << solution(n) << endl;
        return 0;
    }

    ```

13. 最后一个单词长度

    ```c++
    // 用的从后往前检测的方法能快一点
    // 主要还是在于空格的检测

    #include <stdio.h>
    #include <string>
    #include <iostream>

    using namespace std;

    int solution(string s) {
        if (s == "")return 0;
        int l = s.size();
        int n = 0;
        for (int i = 0; i < l; ++i) {
            if (s[l - i - 1] == ' ' && n == 0) {
                continue;
            } else if (s[l - i - 1] == ' ' && n != 0) {
                break;
            }
            n++;
        }
        return n;
    }


    int main() {
        string s = "a bc";
        cout << solution(s) << endl;
        return 0;
    }

    ```

14. 加一

    ```c++
    // 出题人不让用转换成数字的方法做，故意把调试数据放的很长
    // 主要问题在于进位

    #include <stdio.h>
    #include <string>
    #include <iostream>
    #include <vector>

    using namespace std;

    class Solution {
    public:
        vector<int> plusOne(vector<int> &digits) {
            int l = digits.size();
            digits[l - 1] += 1;
            int flag = 0; // 进位标志
            while (l) {
                digits[l - 1] += flag;
                flag = 0;
                if (digits[l - 1] == 10) {
                    if (l - 1 == 0) {
                        digits[0] = 0;
                        digits.insert(digits.begin(), 1);
                        break;
                    }
                    flag = 1;
                    digits[l - 1] = 0;
                }
                l--;
            }
            return digits;
        }
    };


    int main() {
        Solution s;
        vector<int> vec = {9, 9, 9, 9};
        vec = s.plusOne(vec);
        for (int i = 0; i < vec.size(); ++i) {
            cout << vec[i];
        }
        return 0;
    }

    ```

15. 二进制求和  
