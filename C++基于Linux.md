# C++基于Linux

## 库的使用

### 库分类
 
 1. 静态库：静态库的代码在编译过程中已经被载入可执行程序，因此体积较大
 2. 动态库（共享库）：代码不会连接到目标文件之中，只有当动态库可访问时，应用程序才能正确执行动态库函数。执行动态库的方式有隐式调用和显式调用
    1. 隐式调用：也称共享库的静态加载，动态库在应用开始执行时会自动载入内存，进程结束时又自动卸载。隐式调用的编译方式与静态库一致
    2. 显式调用：也称共享库的动态加载，编译时可以不显式的提供原动态库文件及名称，但是必须遵循dlopen等函数的规则实现调用

### 静态库

1. 静态库生成：设计源码->编译`.o`文件->链接静态库，命名规则`libxxx.a`
2. 静态库的应用模型
   1. 调用库函数代码
   2. 编译链接选项

     ```
     # cc -O -o main.c ./libxxx.a
     ```

3. 执行目标程序`# ./main`

### 动态库

1. 动态库生成：
   1. 设计源码（exp：d1.c & d2.c）
   2. Linux和其它使用gcc编译器的Unix

     ```c++
     gcc -fpic -c d1.c d2.c /*编译.o为扩展名的中间目标文件*/
     gcc -shared -0 d1.so d1.o /*创建动态库文件d1.so*/
     gcc -shared -0 d2.so d2.o /*创建动态库文件d2.so*/
     ```

     或者可以一步到位

     ```c++
     gcc -O -fpic -shared -o d1.so d1.c/*创建动态库文件d1.so*/
     gcc -O -fpic -shared -o d2.so d2.c/*创建动态库文件d2.so*/
     ```

2. 动态库的隐式调用
   1. 调用库函数代码（main程序 main.c）
   2. 编译链接选项

     ```
     # cp d1.so dll.so
     # cc -O -o main main.c ./dll.so
     # ./main  /*运行程序*/
     ```

   3. 动态库查找：动态库文件变更位置后程序无法正常运行，解决方法：带路径编译或更改环境变量
   4. 动态库更换：动态链接库取代静态库的好处之一是随时升级库的内容

     ```
     # cp d2.so dll.so
     # ./main
     ```

3. 动态库的显式调用
   1. 函数族：显式调用动态库，编译时无需库文件，执行时动态库可存储于人艺文志，库里共享对象必须先申请后使用，不同版本的动态库，只要其共享对象接口相同，就可以直接动态加载。
      1. 打开动态库

          ```c
          #include <dlfcn.h>
          void *dlopen(const char *pathname, int mode);     /*dlopen加载动态库*/          
          ```

          - pathname：带路径的动态库名
          - mode：动态库加载方式
            - RTLD_LAZY：动态库的对象符号在被调用时解析
            - RTLD_NOW：动态库对象的所有符号在函数dlopen返回前被解析

      2. 获取动态库对象地址

          ```c
          #include <dlfcn.h>
          void *dlsym(const char *handle, const char *name);     /*dlsym在动态库中搜索与字符串name同名的对象*/
          ```

          - handle：由函数dlopen返回成功加载动态库的句柄
          - name：待使用对象的名称（动态库中包含的函数名或变量名）
      3. 错误检查

          ```c
          #include <dlfcn.h>
          char *dlerror(void);     /*获取显示动态库操作中的错误信息*/
          ```

      4. 关闭动态库

          ```c
          #include <dlfcn.h>
          void *dlclose(char *handle);  /*动态库使用完必须关闭*/
          ```

   2. 应用模型：打开动态库->获取对象地址->执行动态对象（可回到上一步）->关闭动态库

### 小结

- 三种库调用对比

     | 对比项         | 静态库     | 隐式调用   | 显式调用 |
     | -------------- | ---------- | ---------- | -------- |
     | 编译参数       | 传递编译器 | 传递编译器 | 不需要   |
     | 链接到目标文件 | 是         | 否         | 否       |
     | 库存储位置     | 不需要     | 特定位置   | 任意位置 |
     | 载入时间       | 进程启动   | 进程启动   | 任意时刻 |

## 




